# elm-indexeddb

IndexedDB support for Elm via [elm-concurrent-task](https://package.elm-lang.org/packages/andrewMacmurray/elm-concurrent-task/latest/).

Two parts: an **Elm module** (`IndexedDb`) and a **JS companion** (`elm-indexeddb`).

## Setup

### Elm

```bash
elm install mpizenberg/elm-indexeddb
```

### JS

```javascript
import * as ConcurrentTask from "@andrewmacmurray/elm-concurrent-task";
import { createTasks } from "elm-indexeddb";

const app = window.Elm.Main.init({ node: document.getElementById("app") });

ConcurrentTask.register({
  tasks: createTasks(),
  ports: { send: app.ports.send, receive: app.ports.receive },
});
```

## Defining Stores

Stores use phantom types to enforce correct key usage at compile time:

```elm
import IndexedDb as Idb

-- InlineKey: key extracted from the value at "id"
todosStore : Idb.Store Idb.InlineKey
todosStore =
    Idb.defineStore "todos"
        |> Idb.withKeyPath "id"

-- GeneratedKey: key auto-generated by IndexedDB
cacheStore : Idb.Store Idb.GeneratedKey
cacheStore =
    Idb.defineStore "cache"
        |> Idb.withAutoIncrement

-- ExplicitKey: key must be provided with each write
settingsStore : Idb.Store Idb.ExplicitKey
settingsStore =
    Idb.defineStore "settings"
```

## Secondary Indexes

Indexes enable efficient queries on fields other than the primary key.

```elm
byTimestamp : Idb.Index
byTimestamp =
    Idb.defineIndex "by_timestamp" "timestamp"

byEmail : Idb.Index
byEmail =
    Idb.defineIndex "by_email" "email"
        |> Idb.uniqueIndex

byTags : Idb.Index
byTags =
    Idb.defineIndex "by_tags" "tags"
        |> Idb.multiEntryIndex

eventsStore : Idb.Store Idb.GeneratedKey
eventsStore =
    Idb.defineStore "events"
        |> Idb.withAutoIncrement
        |> Idb.withIndex byTimestamp
        |> Idb.withIndex byTags
```

- `uniqueIndex`: enforces uniqueness on the indexed field. Adding a duplicate fails with `AlreadyExists`.
- `multiEntryIndex`: if the field contains an array, each element gets its own index entry pointing to the same record.

When you bump the schema version, indexes are synced automatically: new indexes are created and removed indexes are deleted.

## Defining a Schema

```elm
mySchema : Idb.Schema
mySchema =
    Idb.schema "myapp" 1
        |> Idb.withStore todosStore
        |> Idb.withStore settingsStore
        |> Idb.withStore eventsStore
```

When you bump the version number, `open` will automatically:

- Create stores that are new in the schema
- Delete stores that are missing from the schema
- Create or delete indexes to match the schema
- Keep existing data in stores with matching names

## Opening the Database

```elm
import ConcurrentTask exposing (ConcurrentTask)

loadApp : ConcurrentTask Idb.Error Idb.Db
loadApp =
    Idb.open mySchema
```

The returned `Db` handle must be threaded to all subsequent operations.

## Keys

```elm
type Key
    = StringKey String
    | IntKey Int
    | FloatKey Float
    | PosixKey Time.Posix
    | CompoundKey (List Key)
```

`PosixKey` stores timestamps as native `Date` objects in IndexedDB, enabling correct time-based ordering and range queries. Use `keyToPosix` to extract the `Time.Posix` value from a key.

## Key Ranges

Key ranges filter queries at the IndexedDB level, so only matching records are transferred to Elm.

```elm
Idb.only (Idb.StringKey "user-1")                  -- exact match
Idb.from (Idb.IntKey 10)                            -- >= 10
Idb.above (Idb.IntKey 10)                           -- > 10 (exclusive)
Idb.upTo (Idb.IntKey 99)                            -- <= 99
Idb.below (Idb.IntKey 99)                           -- < 99 (exclusive)
Idb.between (Idb.IntKey 10) (Idb.IntKey 99)         -- >= 10 AND <= 99
Idb.between (Idb.PosixKey start) (Idb.PosixKey end) -- time range
```

## Operations

### Reading (any store type)

```elm
Idb.get db todosStore (Idb.StringKey "todo-1") todoDecoder
-- ConcurrentTask Idb.Error (Maybe Todo)

Idb.getAll db todosStore todoDecoder
-- ConcurrentTask Idb.Error (List ( Idb.Key, Todo ))

Idb.getAllKeys db todosStore
-- ConcurrentTask Idb.Error (List Idb.Key)

Idb.count db todosStore
-- ConcurrentTask Idb.Error Int
```

### Reading with key ranges

```elm
Idb.getAllInRange db todosStore (Idb.from (Idb.IntKey 10)) todoDecoder
-- ConcurrentTask Idb.Error (List ( Idb.Key, Todo ))

Idb.getAllKeysInRange db todosStore (Idb.between (Idb.IntKey 1) (Idb.IntKey 50))
-- ConcurrentTask Idb.Error (List Idb.Key)

Idb.countInRange db todosStore (Idb.upTo (Idb.IntKey 99))
-- ConcurrentTask Idb.Error Int
```

### Reading with indexes

```elm
Idb.getByIndex db eventsStore byTimestamp
    (Idb.between (Idb.PosixKey fiveMinAgo) (Idb.PosixKey now))
    eventDecoder
-- ConcurrentTask Idb.Error (List ( Idb.Key, Event ))

Idb.getKeysByIndex db eventsStore byAction (Idb.only (Idb.StringKey "login"))
-- ConcurrentTask Idb.Error (List Idb.Key)

Idb.countByIndex db eventsStore byAction (Idb.only (Idb.StringKey "login"))
-- ConcurrentTask Idb.Error Int
```

Index queries return **primary keys**, so results can be used directly with `get`, `delete`, etc.

### Writing -- InlineKey stores

```elm
Idb.put db todosStore (encodeTodo myTodo)
-- ConcurrentTask Idb.Error Idb.Key  (upsert, returns key from value)

Idb.add db todosStore (encodeTodo myTodo)
-- ConcurrentTask Idb.Error Idb.Key  (insert only, fails if key exists)
```

### Writing -- ExplicitKey stores

```elm
Idb.putAt db settingsStore (Idb.StringKey "theme") (Encode.string "dark")
-- ConcurrentTask Idb.Error ()

Idb.addAt db settingsStore (Idb.StringKey "theme") (Encode.string "dark")
-- ConcurrentTask Idb.Error ()  (fails with AlreadyExists if key exists)
```

### Writing -- GeneratedKey stores

```elm
Idb.insert db cacheStore (Encode.object [ ... ])
-- ConcurrentTask Idb.Error Idb.Key  (always succeeds, returns generated key)

Idb.replace db cacheStore myKey (Encode.object [ ... ])
-- ConcurrentTask Idb.Error ()   (update an existing record by key)
```

### Deleting (any store type)

```elm
Idb.delete db todosStore (Idb.StringKey "todo-1")
Idb.deleteInRange db todosStore (Idb.below (Idb.IntKey 10))
Idb.clear db todosStore
```

### Batch operations (single transaction)

```elm
Idb.putMany db todosStore [ encodeTodo t1, encodeTodo t2 ]
Idb.putManyAt db settingsStore [ ( Idb.StringKey "a", v1 ), ( Idb.StringKey "b", v2 ) ]
Idb.insertMany db cacheStore [ v1, v2, v3 ]
Idb.replaceMany db cacheStore [ ( key1, v1 ), ( key2, v2 ) ]
Idb.deleteMany db todosStore [ Idb.StringKey "todo-1", Idb.StringKey "todo-2" ]
```

## Errors

```elm
type Error
    = AlreadyExists        -- add/addAt on existing key
    | TransactionError String
    | QuotaExceeded
    | DatabaseError String  -- schema mismatch, DB not open, etc.
```

`get` returns `Maybe a` rather than an error when a key is missing -- matching IndexedDB's native behavior.

## Migrations

Structural changes (add/remove stores, add/remove indexes) happen automatically during `open`. For data migrations, chain tasks after opening:

```elm
Idb.open mySchema
    |> ConcurrentTask.andThen (\db -> migrateData db)
    |> ConcurrentTask.andThen (\db -> startApp db)
```

Track a version number in a metadata store to know which data migrations to run.

## Not Yet Supported

- Cursors (streaming iteration over large result sets)
- Multi-store transactions
- Compound key paths
