[{"name":"IndexedDb","comment":" IndexedDB support for Elm via elm-concurrent-task.\n\n\n# Design Decisions\n\n  - Single database per schema — one `Db` handle, one connection\n  - Phantom types enforce key discipline at compile time\n  - Each operation runs in its own transaction (no multi-store transactions)\n  - Batch variants (`putMany`, etc.) run in a single transaction for atomicity\n  - `get` returns `Maybe` for missing keys instead of an error, matching native IndexedDB behavior\n  - Relies on `elm-concurrent-task` for all async JS interop\n\n\n# Not Yet Supported\n\n  - Cursors (streaming iteration over large result sets)\n  - Multi-store transactions\n  - Compound key paths\n\n\n# Initialization\n\n@docs Schema, schema, withStore\n@docs Store, defineStore, withKeyPath, withAutoIncrement\n@docs Index, defineIndex, uniqueIndex, multiEntryIndex, withIndex\n@docs ExplicitKey, InlineKey, GeneratedKey\n\n\n# Database\n\n@docs Db, open, deleteDatabase\n\n\n# Keys\n\n@docs Key, keyToPosix\n\n\n# Key Ranges\n\n@docs KeyRange, only, from, above, upTo, below, between\n\n\n# Read Operations\n\n@docs get, getAll, getAllKeys, count\n@docs getAllInRange, getAllKeysInRange, countInRange\n@docs getByIndex, getKeysByIndex, countByIndex\n\n\n# Write Operations — InlineKey stores\n\n@docs put, add, putMany\n\n\n# Write Operations — ExplicitKey stores\n\n@docs putAt, addAt, putManyAt\n\n\n# Write Operations — GeneratedKey stores\n\n@docs insert, replace, insertMany, replaceMany\n\n\n# Delete Operations\n\n@docs delete, deleteMany, clear, deleteInRange\n\n\n# Errors\n\n@docs Error\n\n","unions":[{"name":"Db","comment":" An opaque handle to an opened database. Must be threaded to all operations.\n","args":[],"cases":[]},{"name":"Error","comment":" Errors that can occur during IndexedDB operations.\n\n  - `AlreadyExists` — Attempted to `add` a record with an existing key.\n  - `TransactionError` — The transaction failed (e.g. was aborted).\n  - `QuotaExceeded` — Storage quota exceeded.\n  - `DatabaseError` — Any other database error (schema mismatch, not open, etc).\n\n","args":[],"cases":[["AlreadyExists",[]],["TransactionError",["String.String"]],["QuotaExceeded",[]],["DatabaseError",["String.String"]]]},{"name":"ExplicitKey","comment":" Marker type for stores where the key must be provided explicitly.\n","args":[],"cases":[]},{"name":"GeneratedKey","comment":" Marker type for stores where the key is auto-generated.\n","args":[],"cases":[]},{"name":"Index","comment":" An index definition for secondary key lookups on a store.\n","args":[],"cases":[]},{"name":"InlineKey","comment":" Marker type for stores where the key is extracted from the value via keyPath.\n","args":[],"cases":[]},{"name":"Key","comment":" A key for IndexedDB records. Constructors are exposed directly.\n\n    StringKey \"user-1\"\n\n    IntKey 42\n\n    PosixKey (Time.millisToPosix 1700000000000)\n\n    CompoundKey [ StringKey \"2024\", IntKey 1 ]\n\n","args":[],"cases":[["StringKey",["String.String"]],["IntKey",["Basics.Int"]],["FloatKey",["Basics.Float"]],["PosixKey",["Time.Posix"]],["CompoundKey",["List.List IndexedDb.Key"]]]},{"name":"KeyRange","comment":" A range of keys for filtering queries at the IndexedDB level.\nUse the convenience constructors below to create ranges.\n","args":[],"cases":[]},{"name":"Schema","comment":" A database schema: name, version, and a list of store definitions.\n","args":[],"cases":[]},{"name":"Store","comment":" A store definition with a phantom type `k` indicating its key configuration.\n","args":["k"],"cases":[]}],"aliases":[],"values":[{"name":"above","comment":" Match all keys strictly greater than the given key (exclusive).\n","type":"IndexedDb.Key -> IndexedDb.KeyRange"},{"name":"add","comment":" Insert a value into an InlineKey store. Fails with `AlreadyExists` if\nthe key (extracted from the value) already exists. Returns the key.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.InlineKey -> Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error IndexedDb.Key"},{"name":"addAt","comment":" Insert a value at the given key in an ExplicitKey store. Fails with\n`AlreadyExists` if the key already exists.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.ExplicitKey -> IndexedDb.Key -> Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"below","comment":" Match all keys strictly less than the given key (exclusive).\n","type":"IndexedDb.Key -> IndexedDb.KeyRange"},{"name":"between","comment":" Match all keys between two bounds (inclusive on both ends).\n","type":"IndexedDb.Key -> IndexedDb.Key -> IndexedDb.KeyRange"},{"name":"clear","comment":" Delete all records in a store.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"count","comment":" Count the number of records in a store.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> ConcurrentTask.ConcurrentTask IndexedDb.Error Basics.Int"},{"name":"countByIndex","comment":" Count records matching an index key range.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.Index -> IndexedDb.KeyRange -> ConcurrentTask.ConcurrentTask IndexedDb.Error Basics.Int"},{"name":"countInRange","comment":" Count records whose primary key falls within a range.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.KeyRange -> ConcurrentTask.ConcurrentTask IndexedDb.Error Basics.Int"},{"name":"defineIndex","comment":" Define a new index with a name and keyPath. By default, the index is\nnon-unique and single-entry.\n\n    byTimestamp : Index\n    byTimestamp =\n        defineIndex \"by_timestamp\" \"timestamp\"\n\n","type":"String.String -> String.String -> IndexedDb.Index"},{"name":"defineStore","comment":" Define a new store with explicit keys (no keyPath, no autoIncrement).\n\n    rawStore : Store ExplicitKey\n    rawStore =\n        defineStore \"raw\"\n\n","type":"String.String -> IndexedDb.Store IndexedDb.ExplicitKey"},{"name":"delete","comment":" Delete a record by key.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.Key -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"deleteDatabase","comment":" Delete a database. Closes the connection first.\n","type":"IndexedDb.Db -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"deleteInRange","comment":" Delete all records whose primary key falls within a range.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.KeyRange -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"deleteMany","comment":" Delete many records by key in a single transaction.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> List.List IndexedDb.Key -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"from","comment":" Match all keys greater than or equal to the given key (inclusive).\n","type":"IndexedDb.Key -> IndexedDb.KeyRange"},{"name":"get","comment":" Get a single record by key. Returns `Nothing` if the key doesn't exist.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.Key -> Json.Decode.Decoder a -> ConcurrentTask.ConcurrentTask IndexedDb.Error (Maybe.Maybe a)"},{"name":"getAll","comment":" Get all records in a store, with their keys.\nBoth keys and values are retrieved in a single transaction for consistency.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> Json.Decode.Decoder a -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List ( IndexedDb.Key, a ))"},{"name":"getAllInRange","comment":" Get all records whose primary key falls within a range, with their keys.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.KeyRange -> Json.Decode.Decoder a -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List ( IndexedDb.Key, a ))"},{"name":"getAllKeys","comment":" Get all primary keys in a store.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List IndexedDb.Key)"},{"name":"getAllKeysInRange","comment":" Get all primary keys that fall within a range.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.KeyRange -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List IndexedDb.Key)"},{"name":"getByIndex","comment":" Get all records matching an index key range, with their primary keys.\nThe returned keys are primary keys, usable with `get`, `delete`, etc.\n\n    Idb.getByIndex db\n        eventsStore\n        byTimestamp\n        (Idb.between (Idb.PosixKey start) (Idb.PosixKey end))\n        eventDecoder\n\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.Index -> IndexedDb.KeyRange -> Json.Decode.Decoder a -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List ( IndexedDb.Key, a ))"},{"name":"getKeysByIndex","comment":" Get all primary keys for records matching an index key range.\n","type":"IndexedDb.Db -> IndexedDb.Store k -> IndexedDb.Index -> IndexedDb.KeyRange -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List IndexedDb.Key)"},{"name":"insert","comment":" Insert a value into a GeneratedKey store. The key is auto-generated.\nReturns the generated key.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.GeneratedKey -> Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error IndexedDb.Key"},{"name":"insertMany","comment":" Insert many values into a GeneratedKey store in a single transaction.\nReturns the generated keys in the same order as the input values.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.GeneratedKey -> List.List Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error (List.List IndexedDb.Key)"},{"name":"keyToPosix","comment":" Extract a `Time.Posix` from a key, if it is a `PosixKey`.\n","type":"IndexedDb.Key -> Maybe.Maybe Time.Posix"},{"name":"multiEntryIndex","comment":" Make an index treat array values as multiple entries. Each element\nof the array gets its own entry in the index, all pointing to the same record.\n\n    byTags : Index\n    byTags =\n        defineIndex \"by_tags\" \"tags\"\n            |> multiEntryIndex\n\n","type":"IndexedDb.Index -> IndexedDb.Index"},{"name":"only","comment":" Match a single key exactly.\n","type":"IndexedDb.Key -> IndexedDb.KeyRange"},{"name":"open","comment":" Open a database with the given schema. Creates or upgrades the database\nas needed (adding new stores, removing stores not in the schema).\n\n    open mySchema\n\n","type":"IndexedDb.Schema -> ConcurrentTask.ConcurrentTask IndexedDb.Error IndexedDb.Db"},{"name":"put","comment":" Upsert a value into an InlineKey store. The key is extracted from the\nvalue at the store's keyPath. Returns the key.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.InlineKey -> Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error IndexedDb.Key"},{"name":"putAt","comment":" Upsert a value at the given key in an ExplicitKey store.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.ExplicitKey -> IndexedDb.Key -> Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"putMany","comment":" Put many values into an InlineKey store in a single transaction.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.InlineKey -> List.List Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"putManyAt","comment":" Put many key-value pairs into an ExplicitKey store in a single transaction.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.ExplicitKey -> List.List ( IndexedDb.Key, Json.Encode.Value ) -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"replace","comment":" Replace a value at the given key in a GeneratedKey store.\nUse this to update an existing record whose key was returned by `insert`.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.GeneratedKey -> IndexedDb.Key -> Json.Encode.Value -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"replaceMany","comment":" Replace many values in a GeneratedKey store in a single transaction.\nUse this to update existing records whose keys were returned by `insert` or `insertMany`.\n","type":"IndexedDb.Db -> IndexedDb.Store IndexedDb.GeneratedKey -> List.List ( IndexedDb.Key, Json.Encode.Value ) -> ConcurrentTask.ConcurrentTask IndexedDb.Error ()"},{"name":"schema","comment":" Start building a schema with a database name and version number.\n\n    mySchema : Schema\n    mySchema =\n        schema \"myapp\" 1\n            |> withStore todosStore\n            |> withStore cacheStore\n\n","type":"String.String -> Basics.Int -> IndexedDb.Schema"},{"name":"uniqueIndex","comment":" Make an index enforce uniqueness. Adding a record with a duplicate\nvalue for this index's keyPath will fail with `AlreadyExists`.\n\n    byEmail : Index\n    byEmail =\n        defineIndex \"by_email\" \"email\"\n            |> uniqueIndex\n\n","type":"IndexedDb.Index -> IndexedDb.Index"},{"name":"upTo","comment":" Match all keys less than or equal to the given key (inclusive).\n","type":"IndexedDb.Key -> IndexedDb.KeyRange"},{"name":"withAutoIncrement","comment":" Enable auto-increment on a store, making it a GeneratedKey store.\n\n    cacheStore : Store GeneratedKey\n    cacheStore =\n        defineStore \"cache\"\n            |> withAutoIncrement\n\n","type":"IndexedDb.Store IndexedDb.ExplicitKey -> IndexedDb.Store IndexedDb.GeneratedKey"},{"name":"withIndex","comment":" Add an index to a store. The index is used for secondary key lookups\nand range queries on fields other than the primary key.\n\n    eventsStore : Store InlineKey\n    eventsStore =\n        defineStore \"events\"\n            |> withKeyPath \"id\"\n            |> withIndex (defineIndex \"by_timestamp\" \"timestamp\")\n\n","type":"IndexedDb.Index -> IndexedDb.Store k -> IndexedDb.Store k"},{"name":"withKeyPath","comment":" Set a keyPath on a store, making it an InlineKey store.\n\n    todosStore : Store InlineKey\n    todosStore =\n        defineStore \"todos\"\n            |> withKeyPath \"id\"\n\n","type":"String.String -> IndexedDb.Store IndexedDb.ExplicitKey -> IndexedDb.Store IndexedDb.InlineKey"},{"name":"withStore","comment":" Add a store to the schema. The phantom type is erased—stores of any key\nconfiguration can be added to the same schema.\n","type":"IndexedDb.Store k -> IndexedDb.Schema -> IndexedDb.Schema"}],"binops":[]}]